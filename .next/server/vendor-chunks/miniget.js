"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/miniget";
exports.ids = ["vendor-chunks/miniget"];
exports.modules = {

/***/ "(rsc)/./node_modules/miniget/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/miniget/dist/index.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst http_1 = __importDefault(__webpack_require__(/*! http */ \"http\"));\nconst https_1 = __importDefault(__webpack_require__(/*! https */ \"https\"));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst httpLibs = { 'http:': http_1.default, 'https:': https_1.default };\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst retryStatusCodes = new Set([429, 503]);\n// `request`, `response`, `abort`, left out, miniget will emit these.\nconst requestEvents = ['connect', 'continue', 'information', 'socket', 'timeout', 'upgrade'];\nconst responseEvents = ['aborted'];\nMiniget.MinigetError = class MinigetError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.statusCode = statusCode;\n    }\n};\nMiniget.defaultOptions = {\n    maxRedirects: 10,\n    maxRetries: 2,\n    maxReconnects: 0,\n    backoff: { inc: 100, max: 10000 },\n};\nfunction Miniget(url, options = {}) {\n    var _a;\n    const opts = Object.assign({}, Miniget.defaultOptions, options);\n    const stream = new stream_1.PassThrough({ highWaterMark: opts.highWaterMark });\n    stream.destroyed = stream.aborted = false;\n    let activeRequest;\n    let activeResponse;\n    let activeDecodedStream;\n    let redirects = 0;\n    let retries = 0;\n    let retryTimeout;\n    let reconnects = 0;\n    let contentLength;\n    let acceptRanges = false;\n    let rangeStart = 0, rangeEnd;\n    let downloaded = 0;\n    // Check if this is a ranged request.\n    if ((_a = opts.headers) === null || _a === void 0 ? void 0 : _a.Range) {\n        let r = /bytes=(\\d+)-(\\d+)?/.exec(`${opts.headers.Range}`);\n        if (r) {\n            rangeStart = parseInt(r[1], 10);\n            rangeEnd = parseInt(r[2], 10);\n        }\n    }\n    // Add `Accept-Encoding` header.\n    if (opts.acceptEncoding) {\n        opts.headers = Object.assign({\n            'Accept-Encoding': Object.keys(opts.acceptEncoding).join(', '),\n        }, opts.headers);\n    }\n    const downloadHasStarted = () => activeDecodedStream && downloaded > 0;\n    const downloadComplete = () => !acceptRanges || downloaded === contentLength;\n    const reconnect = (err) => {\n        activeDecodedStream = null;\n        retries = 0;\n        let inc = opts.backoff.inc;\n        let ms = Math.min(inc, opts.backoff.max);\n        retryTimeout = setTimeout(doDownload, ms);\n        stream.emit('reconnect', reconnects, err);\n    };\n    const reconnectIfEndedEarly = (err) => {\n        if (options.method !== 'HEAD' && !downloadComplete() && reconnects++ < opts.maxReconnects) {\n            reconnect(err);\n            return true;\n        }\n        return false;\n    };\n    const retryRequest = (retryOptions) => {\n        if (stream.destroyed) {\n            return false;\n        }\n        if (downloadHasStarted()) {\n            return reconnectIfEndedEarly(retryOptions.err);\n        }\n        else if ((!retryOptions.err || retryOptions.err.message === 'ENOTFOUND') &&\n            retries++ < opts.maxRetries) {\n            let ms = retryOptions.retryAfter ||\n                Math.min(retries * opts.backoff.inc, opts.backoff.max);\n            retryTimeout = setTimeout(doDownload, ms);\n            stream.emit('retry', retries, retryOptions.err);\n            return true;\n        }\n        return false;\n    };\n    const forwardEvents = (ee, events) => {\n        for (let event of events) {\n            ee.on(event, stream.emit.bind(stream, event));\n        }\n    };\n    const doDownload = () => {\n        let parsed = {}, httpLib;\n        try {\n            let urlObj = typeof url === 'string' ? new URL(url) : url;\n            parsed = Object.assign({}, {\n                host: urlObj.host,\n                hostname: urlObj.hostname,\n                path: urlObj.pathname + urlObj.search + urlObj.hash,\n                port: urlObj.port,\n                protocol: urlObj.protocol,\n            });\n            if (urlObj.username) {\n                parsed.auth = `${urlObj.username}:${urlObj.password}`;\n            }\n            httpLib = httpLibs[String(parsed.protocol)];\n        }\n        catch (err) {\n            // Let the error be caught by the if statement below.\n        }\n        if (!httpLib) {\n            stream.emit('error', new Miniget.MinigetError(`Invalid URL: ${url}`));\n            return;\n        }\n        Object.assign(parsed, opts);\n        if (acceptRanges && downloaded > 0) {\n            let start = downloaded + rangeStart;\n            let end = rangeEnd || '';\n            parsed.headers = Object.assign({}, parsed.headers, {\n                Range: `bytes=${start}-${end}`,\n            });\n        }\n        if (opts.transform) {\n            try {\n                parsed = opts.transform(parsed);\n            }\n            catch (err) {\n                stream.emit('error', err);\n                return;\n            }\n            if (!parsed || parsed.protocol) {\n                httpLib = httpLibs[String(parsed === null || parsed === void 0 ? void 0 : parsed.protocol)];\n                if (!httpLib) {\n                    stream.emit('error', new Miniget.MinigetError('Invalid URL object from `transform` function'));\n                    return;\n                }\n            }\n        }\n        const onError = (err) => {\n            if (stream.destroyed || stream.readableEnded) {\n                return;\n            }\n            cleanup();\n            if (!retryRequest({ err })) {\n                stream.emit('error', err);\n            }\n            else {\n                activeRequest.removeListener('close', onRequestClose);\n            }\n        };\n        const onRequestClose = () => {\n            cleanup();\n            retryRequest({});\n        };\n        const cleanup = () => {\n            activeRequest.removeListener('close', onRequestClose);\n            activeResponse === null || activeResponse === void 0 ? void 0 : activeResponse.removeListener('data', onData);\n            activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.removeListener('end', onEnd);\n        };\n        const onData = (chunk) => { downloaded += chunk.length; };\n        const onEnd = () => {\n            cleanup();\n            if (!reconnectIfEndedEarly()) {\n                stream.end();\n            }\n        };\n        activeRequest = httpLib.request(parsed, (res) => {\n            // Needed for node v10, v12.\n            // istanbul ignore next\n            if (stream.destroyed) {\n                return;\n            }\n            if (redirectStatusCodes.has(res.statusCode)) {\n                if (redirects++ >= opts.maxRedirects) {\n                    stream.emit('error', new Miniget.MinigetError('Too many redirects'));\n                }\n                else {\n                    if (res.headers.location) {\n                        url = res.headers.location;\n                    }\n                    else {\n                        let err = new Miniget.MinigetError('Redirect status code given with no location', res.statusCode);\n                        stream.emit('error', err);\n                        cleanup();\n                        return;\n                    }\n                    setTimeout(doDownload, parseInt(res.headers['retry-after'] || '0', 10) * 1000);\n                    stream.emit('redirect', url);\n                }\n                cleanup();\n                return;\n                // Check for rate limiting.\n            }\n            else if (retryStatusCodes.has(res.statusCode)) {\n                if (!retryRequest({ retryAfter: parseInt(res.headers['retry-after'] || '0', 10) })) {\n                    let err = new Miniget.MinigetError(`Status code: ${res.statusCode}`, res.statusCode);\n                    stream.emit('error', err);\n                }\n                cleanup();\n                return;\n            }\n            else if (res.statusCode && (res.statusCode < 200 || res.statusCode >= 400)) {\n                let err = new Miniget.MinigetError(`Status code: ${res.statusCode}`, res.statusCode);\n                if (res.statusCode >= 500) {\n                    onError(err);\n                }\n                else {\n                    stream.emit('error', err);\n                }\n                cleanup();\n                return;\n            }\n            activeDecodedStream = res;\n            if (opts.acceptEncoding && res.headers['content-encoding']) {\n                for (let enc of res.headers['content-encoding'].split(', ').reverse()) {\n                    let fn = opts.acceptEncoding[enc];\n                    if (fn) {\n                        activeDecodedStream = activeDecodedStream.pipe(fn());\n                        activeDecodedStream.on('error', onError);\n                    }\n                }\n            }\n            if (!contentLength) {\n                contentLength = parseInt(`${res.headers['content-length']}`, 10);\n                acceptRanges = res.headers['accept-ranges'] === 'bytes' &&\n                    contentLength > 0 && opts.maxReconnects > 0;\n            }\n            res.on('data', onData);\n            activeDecodedStream.on('end', onEnd);\n            activeDecodedStream.pipe(stream, { end: !acceptRanges });\n            activeResponse = res;\n            stream.emit('response', res);\n            res.on('error', onError);\n            forwardEvents(res, responseEvents);\n        });\n        activeRequest.on('error', onError);\n        activeRequest.on('close', onRequestClose);\n        forwardEvents(activeRequest, requestEvents);\n        if (stream.destroyed) {\n            streamDestroy(...destroyArgs);\n        }\n        stream.emit('request', activeRequest);\n        activeRequest.end();\n    };\n    stream.abort = (err) => {\n        console.warn('`MinigetStream#abort()` has been deprecated in favor of `MinigetStream#destroy()`');\n        stream.aborted = true;\n        stream.emit('abort');\n        stream.destroy(err);\n    };\n    let destroyArgs = [];\n    const streamDestroy = (err) => {\n        activeRequest.destroy(err);\n        activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.unpipe(stream);\n        activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.destroy();\n        clearTimeout(retryTimeout);\n    };\n    stream._destroy = (...args) => {\n        stream.destroyed = true;\n        if (activeRequest) {\n            streamDestroy(...args);\n        }\n        else {\n            destroyArgs = args;\n        }\n    };\n    stream.text = () => new Promise((resolve, reject) => {\n        let body = '';\n        stream.setEncoding('utf8');\n        stream.on('data', chunk => body += chunk);\n        stream.on('end', () => resolve(body));\n        stream.on('error', reject);\n    });\n    process.nextTick(doDownload);\n    return stream;\n}\nmodule.exports = Miniget;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWluaWdldC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3QyxnQ0FBZ0MsbUJBQU8sQ0FBQyxvQkFBTztBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxpQ0FBaUM7QUFDakMsOENBQThDLG1DQUFtQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxpQ0FBaUMsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLGdDQUFnQyxNQUFNLEdBQUcsSUFBSTtBQUM3QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2REFBNkQ7QUFDakcsdUVBQXVFLGVBQWU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGVBQWU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw4QkFBOEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQkFBb0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxCdXJha1xcRG9jdW1lbnRzXFxHaXRIdWJcXHlvdXR1YmUtZG93bmxvYWRlclxcbm9kZV9tb2R1bGVzXFxtaW5pZ2V0XFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbmNvbnN0IGh0dHBfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaHR0cFwiKSk7XG5jb25zdCBodHRwc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJodHRwc1wiKSk7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBodHRwTGlicyA9IHsgJ2h0dHA6JzogaHR0cF8xLmRlZmF1bHQsICdodHRwczonOiBodHRwc18xLmRlZmF1bHQgfTtcbmNvbnN0IHJlZGlyZWN0U3RhdHVzQ29kZXMgPSBuZXcgU2V0KFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pO1xuY29uc3QgcmV0cnlTdGF0dXNDb2RlcyA9IG5ldyBTZXQoWzQyOSwgNTAzXSk7XG4vLyBgcmVxdWVzdGAsIGByZXNwb25zZWAsIGBhYm9ydGAsIGxlZnQgb3V0LCBtaW5pZ2V0IHdpbGwgZW1pdCB0aGVzZS5cbmNvbnN0IHJlcXVlc3RFdmVudHMgPSBbJ2Nvbm5lY3QnLCAnY29udGludWUnLCAnaW5mb3JtYXRpb24nLCAnc29ja2V0JywgJ3RpbWVvdXQnLCAndXBncmFkZSddO1xuY29uc3QgcmVzcG9uc2VFdmVudHMgPSBbJ2Fib3J0ZWQnXTtcbk1pbmlnZXQuTWluaWdldEVycm9yID0gY2xhc3MgTWluaWdldEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgfVxufTtcbk1pbmlnZXQuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICBtYXhSZXRyaWVzOiAyLFxuICAgIG1heFJlY29ubmVjdHM6IDAsXG4gICAgYmFja29mZjogeyBpbmM6IDEwMCwgbWF4OiAxMDAwMCB9LFxufTtcbmZ1bmN0aW9uIE1pbmlnZXQodXJsLCBvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIE1pbmlnZXQuZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBzdHJlYW1fMS5QYXNzVGhyb3VnaCh7IGhpZ2hXYXRlck1hcms6IG9wdHMuaGlnaFdhdGVyTWFyayB9KTtcbiAgICBzdHJlYW0uZGVzdHJveWVkID0gc3RyZWFtLmFib3J0ZWQgPSBmYWxzZTtcbiAgICBsZXQgYWN0aXZlUmVxdWVzdDtcbiAgICBsZXQgYWN0aXZlUmVzcG9uc2U7XG4gICAgbGV0IGFjdGl2ZURlY29kZWRTdHJlYW07XG4gICAgbGV0IHJlZGlyZWN0cyA9IDA7XG4gICAgbGV0IHJldHJpZXMgPSAwO1xuICAgIGxldCByZXRyeVRpbWVvdXQ7XG4gICAgbGV0IHJlY29ubmVjdHMgPSAwO1xuICAgIGxldCBjb250ZW50TGVuZ3RoO1xuICAgIGxldCBhY2NlcHRSYW5nZXMgPSBmYWxzZTtcbiAgICBsZXQgcmFuZ2VTdGFydCA9IDAsIHJhbmdlRW5kO1xuICAgIGxldCBkb3dubG9hZGVkID0gMDtcbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgcmFuZ2VkIHJlcXVlc3QuXG4gICAgaWYgKChfYSA9IG9wdHMuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLlJhbmdlKSB7XG4gICAgICAgIGxldCByID0gL2J5dGVzPShcXGQrKS0oXFxkKyk/Ly5leGVjKGAke29wdHMuaGVhZGVycy5SYW5nZX1gKTtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSBwYXJzZUludChyWzFdLCAxMCk7XG4gICAgICAgICAgICByYW5nZUVuZCA9IHBhcnNlSW50KHJbMl0sIDEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGQgYEFjY2VwdC1FbmNvZGluZ2AgaGVhZGVyLlxuICAgIGlmIChvcHRzLmFjY2VwdEVuY29kaW5nKSB7XG4gICAgICAgIG9wdHMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgJ0FjY2VwdC1FbmNvZGluZyc6IE9iamVjdC5rZXlzKG9wdHMuYWNjZXB0RW5jb2RpbmcpLmpvaW4oJywgJyksXG4gICAgICAgIH0sIG9wdHMuaGVhZGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGRvd25sb2FkSGFzU3RhcnRlZCA9ICgpID0+IGFjdGl2ZURlY29kZWRTdHJlYW0gJiYgZG93bmxvYWRlZCA+IDA7XG4gICAgY29uc3QgZG93bmxvYWRDb21wbGV0ZSA9ICgpID0+ICFhY2NlcHRSYW5nZXMgfHwgZG93bmxvYWRlZCA9PT0gY29udGVudExlbmd0aDtcbiAgICBjb25zdCByZWNvbm5lY3QgPSAoZXJyKSA9PiB7XG4gICAgICAgIGFjdGl2ZURlY29kZWRTdHJlYW0gPSBudWxsO1xuICAgICAgICByZXRyaWVzID0gMDtcbiAgICAgICAgbGV0IGluYyA9IG9wdHMuYmFja29mZi5pbmM7XG4gICAgICAgIGxldCBtcyA9IE1hdGgubWluKGluYywgb3B0cy5iYWNrb2ZmLm1heCk7XG4gICAgICAgIHJldHJ5VGltZW91dCA9IHNldFRpbWVvdXQoZG9Eb3dubG9hZCwgbXMpO1xuICAgICAgICBzdHJlYW0uZW1pdCgncmVjb25uZWN0JywgcmVjb25uZWN0cywgZXJyKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlY29ubmVjdElmRW5kZWRFYXJseSA9IChlcnIpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMubWV0aG9kICE9PSAnSEVBRCcgJiYgIWRvd25sb2FkQ29tcGxldGUoKSAmJiByZWNvbm5lY3RzKysgPCBvcHRzLm1heFJlY29ubmVjdHMpIHtcbiAgICAgICAgICAgIHJlY29ubmVjdChlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgcmV0cnlSZXF1ZXN0ID0gKHJldHJ5T3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAoc3RyZWFtLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb3dubG9hZEhhc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29ubmVjdElmRW5kZWRFYXJseShyZXRyeU9wdGlvbnMuZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoIXJldHJ5T3B0aW9ucy5lcnIgfHwgcmV0cnlPcHRpb25zLmVyci5tZXNzYWdlID09PSAnRU5PVEZPVU5EJykgJiZcbiAgICAgICAgICAgIHJldHJpZXMrKyA8IG9wdHMubWF4UmV0cmllcykge1xuICAgICAgICAgICAgbGV0IG1zID0gcmV0cnlPcHRpb25zLnJldHJ5QWZ0ZXIgfHxcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihyZXRyaWVzICogb3B0cy5iYWNrb2ZmLmluYywgb3B0cy5iYWNrb2ZmLm1heCk7XG4gICAgICAgICAgICByZXRyeVRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvRG93bmxvYWQsIG1zKTtcbiAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdyZXRyeScsIHJldHJpZXMsIHJldHJ5T3B0aW9ucy5lcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgZm9yd2FyZEV2ZW50cyA9IChlZSwgZXZlbnRzKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgICAgZWUub24oZXZlbnQsIHN0cmVhbS5lbWl0LmJpbmQoc3RyZWFtLCBldmVudCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkb0Rvd25sb2FkID0gKCkgPT4ge1xuICAgICAgICBsZXQgcGFyc2VkID0ge30sIGh0dHBMaWI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgdXJsT2JqID0gdHlwZW9mIHVybCA9PT0gJ3N0cmluZycgPyBuZXcgVVJMKHVybCkgOiB1cmw7XG4gICAgICAgICAgICBwYXJzZWQgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgICAgICAgICAgaG9zdDogdXJsT2JqLmhvc3QsXG4gICAgICAgICAgICAgICAgaG9zdG5hbWU6IHVybE9iai5ob3N0bmFtZSxcbiAgICAgICAgICAgICAgICBwYXRoOiB1cmxPYmoucGF0aG5hbWUgKyB1cmxPYmouc2VhcmNoICsgdXJsT2JqLmhhc2gsXG4gICAgICAgICAgICAgICAgcG9ydDogdXJsT2JqLnBvcnQsXG4gICAgICAgICAgICAgICAgcHJvdG9jb2w6IHVybE9iai5wcm90b2NvbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHVybE9iai51c2VybmFtZSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5hdXRoID0gYCR7dXJsT2JqLnVzZXJuYW1lfToke3VybE9iai5wYXNzd29yZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHR0cExpYiA9IGh0dHBMaWJzW1N0cmluZyhwYXJzZWQucHJvdG9jb2wpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBMZXQgdGhlIGVycm9yIGJlIGNhdWdodCBieSB0aGUgaWYgc3RhdGVtZW50IGJlbG93LlxuICAgICAgICB9XG4gICAgICAgIGlmICghaHR0cExpYikge1xuICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IE1pbmlnZXQuTWluaWdldEVycm9yKGBJbnZhbGlkIFVSTDogJHt1cmx9YCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VkLCBvcHRzKTtcbiAgICAgICAgaWYgKGFjY2VwdFJhbmdlcyAmJiBkb3dubG9hZGVkID4gMCkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gZG93bmxvYWRlZCArIHJhbmdlU3RhcnQ7XG4gICAgICAgICAgICBsZXQgZW5kID0gcmFuZ2VFbmQgfHwgJyc7XG4gICAgICAgICAgICBwYXJzZWQuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZC5oZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgUmFuZ2U6IGBieXRlcz0ke3N0YXJ0fS0ke2VuZH1gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IG9wdHMudHJhbnNmb3JtKHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcnNlZCB8fCBwYXJzZWQucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICBodHRwTGliID0gaHR0cExpYnNbU3RyaW5nKHBhcnNlZCA9PT0gbnVsbCB8fCBwYXJzZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnNlZC5wcm90b2NvbCldO1xuICAgICAgICAgICAgICAgIGlmICghaHR0cExpYikge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgTWluaWdldC5NaW5pZ2V0RXJyb3IoJ0ludmFsaWQgVVJMIG9iamVjdCBmcm9tIGB0cmFuc2Zvcm1gIGZ1bmN0aW9uJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLmRlc3Ryb3llZCB8fCBzdHJlYW0ucmVhZGFibGVFbmRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIGlmICghcmV0cnlSZXF1ZXN0KHsgZXJyIH0pKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25SZXF1ZXN0Q2xvc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvblJlcXVlc3RDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHJldHJ5UmVxdWVzdCh7fSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICBhY3RpdmVSZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uUmVxdWVzdENsb3NlKTtcbiAgICAgICAgICAgIGFjdGl2ZVJlc3BvbnNlID09PSBudWxsIHx8IGFjdGl2ZVJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVSZXNwb25zZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uRGF0YSk7XG4gICAgICAgICAgICBhY3RpdmVEZWNvZGVkU3RyZWFtID09PSBudWxsIHx8IGFjdGl2ZURlY29kZWRTdHJlYW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZURlY29kZWRTdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRW5kKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25EYXRhID0gKGNodW5rKSA9PiB7IGRvd25sb2FkZWQgKz0gY2h1bmsubGVuZ3RoOyB9O1xuICAgICAgICBjb25zdCBvbkVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIGlmICghcmVjb25uZWN0SWZFbmRlZEVhcmx5KCkpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFjdGl2ZVJlcXVlc3QgPSBodHRwTGliLnJlcXVlc3QocGFyc2VkLCAocmVzKSA9PiB7XG4gICAgICAgICAgICAvLyBOZWVkZWQgZm9yIG5vZGUgdjEwLCB2MTIuXG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgaWYgKHN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVkaXJlY3RTdGF0dXNDb2Rlcy5oYXMocmVzLnN0YXR1c0NvZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZGlyZWN0cysrID49IG9wdHMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBNaW5pZ2V0Lk1pbmlnZXRFcnJvcignVG9vIG1hbnkgcmVkaXJlY3RzJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5oZWFkZXJzLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnIgPSBuZXcgTWluaWdldC5NaW5pZ2V0RXJyb3IoJ1JlZGlyZWN0IHN0YXR1cyBjb2RlIGdpdmVuIHdpdGggbm8gbG9jYXRpb24nLCByZXMuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZG9Eb3dubG9hZCwgcGFyc2VJbnQocmVzLmhlYWRlcnNbJ3JldHJ5LWFmdGVyJ10gfHwgJzAnLCAxMCkgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ3JlZGlyZWN0JywgdXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgcmF0ZSBsaW1pdGluZy5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJldHJ5U3RhdHVzQ29kZXMuaGFzKHJlcy5zdGF0dXNDb2RlKSkge1xuICAgICAgICAgICAgICAgIGlmICghcmV0cnlSZXF1ZXN0KHsgcmV0cnlBZnRlcjogcGFyc2VJbnQocmVzLmhlYWRlcnNbJ3JldHJ5LWFmdGVyJ10gfHwgJzAnLCAxMCkgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVyciA9IG5ldyBNaW5pZ2V0Lk1pbmlnZXRFcnJvcihgU3RhdHVzIGNvZGU6ICR7cmVzLnN0YXR1c0NvZGV9YCwgcmVzLnN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzLnN0YXR1c0NvZGUgJiYgKHJlcy5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlcy5zdGF0dXNDb2RlID49IDQwMCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXJyID0gbmV3IE1pbmlnZXQuTWluaWdldEVycm9yKGBTdGF0dXMgY29kZTogJHtyZXMuc3RhdHVzQ29kZX1gLCByZXMuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID49IDUwMCkge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlRGVjb2RlZFN0cmVhbSA9IHJlcztcbiAgICAgICAgICAgIGlmIChvcHRzLmFjY2VwdEVuY29kaW5nICYmIHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlbmMgb2YgcmVzLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXS5zcGxpdCgnLCAnKS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZuID0gb3B0cy5hY2NlcHRFbmNvZGluZ1tlbmNdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZURlY29kZWRTdHJlYW0gPSBhY3RpdmVEZWNvZGVkU3RyZWFtLnBpcGUoZm4oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVEZWNvZGVkU3RyZWFtLm9uKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29udGVudExlbmd0aCA9IHBhcnNlSW50KGAke3Jlcy5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddfWAsIDEwKTtcbiAgICAgICAgICAgICAgICBhY2NlcHRSYW5nZXMgPSByZXMuaGVhZGVyc1snYWNjZXB0LXJhbmdlcyddID09PSAnYnl0ZXMnICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRMZW5ndGggPiAwICYmIG9wdHMubWF4UmVjb25uZWN0cyA+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMub24oJ2RhdGEnLCBvbkRhdGEpO1xuICAgICAgICAgICAgYWN0aXZlRGVjb2RlZFN0cmVhbS5vbignZW5kJywgb25FbmQpO1xuICAgICAgICAgICAgYWN0aXZlRGVjb2RlZFN0cmVhbS5waXBlKHN0cmVhbSwgeyBlbmQ6ICFhY2NlcHRSYW5nZXMgfSk7XG4gICAgICAgICAgICBhY3RpdmVSZXNwb25zZSA9IHJlcztcbiAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdyZXNwb25zZScsIHJlcyk7XG4gICAgICAgICAgICByZXMub24oJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICBmb3J3YXJkRXZlbnRzKHJlcywgcmVzcG9uc2VFdmVudHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgYWN0aXZlUmVxdWVzdC5vbignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgYWN0aXZlUmVxdWVzdC5vbignY2xvc2UnLCBvblJlcXVlc3RDbG9zZSk7XG4gICAgICAgIGZvcndhcmRFdmVudHMoYWN0aXZlUmVxdWVzdCwgcmVxdWVzdEV2ZW50cyk7XG4gICAgICAgIGlmIChzdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICBzdHJlYW1EZXN0cm95KC4uLmRlc3Ryb3lBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uZW1pdCgncmVxdWVzdCcsIGFjdGl2ZVJlcXVlc3QpO1xuICAgICAgICBhY3RpdmVSZXF1ZXN0LmVuZCgpO1xuICAgIH07XG4gICAgc3RyZWFtLmFib3J0ID0gKGVycikgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2BNaW5pZ2V0U3RyZWFtI2Fib3J0KClgIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYE1pbmlnZXRTdHJlYW0jZGVzdHJveSgpYCcpO1xuICAgICAgICBzdHJlYW0uYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdhYm9ydCcpO1xuICAgICAgICBzdHJlYW0uZGVzdHJveShlcnIpO1xuICAgIH07XG4gICAgbGV0IGRlc3Ryb3lBcmdzID0gW107XG4gICAgY29uc3Qgc3RyZWFtRGVzdHJveSA9IChlcnIpID0+IHtcbiAgICAgICAgYWN0aXZlUmVxdWVzdC5kZXN0cm95KGVycik7XG4gICAgICAgIGFjdGl2ZURlY29kZWRTdHJlYW0gPT09IG51bGwgfHwgYWN0aXZlRGVjb2RlZFN0cmVhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlRGVjb2RlZFN0cmVhbS51bnBpcGUoc3RyZWFtKTtcbiAgICAgICAgYWN0aXZlRGVjb2RlZFN0cmVhbSA9PT0gbnVsbCB8fCBhY3RpdmVEZWNvZGVkU3RyZWFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVEZWNvZGVkU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJldHJ5VGltZW91dCk7XG4gICAgfTtcbiAgICBzdHJlYW0uX2Rlc3Ryb3kgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBzdHJlYW0uZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGFjdGl2ZVJlcXVlc3QpIHtcbiAgICAgICAgICAgIHN0cmVhbURlc3Ryb3koLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXN0cm95QXJncyA9IGFyZ3M7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHN0cmVhbS50ZXh0ID0gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgYm9keSA9ICcnO1xuICAgICAgICBzdHJlYW0uc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcbiAgICAgICAgc3RyZWFtLm9uKCdkYXRhJywgY2h1bmsgPT4gYm9keSArPSBjaHVuayk7XG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgKCkgPT4gcmVzb2x2ZShib2R5KSk7XG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCByZWplY3QpO1xuICAgIH0pO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZG9Eb3dubG9hZCk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbn1cbm1vZHVsZS5leHBvcnRzID0gTWluaWdldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miniget/dist/index.js\n");

/***/ })

};
;