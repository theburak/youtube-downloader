"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/m3u8stream";
exports.ids = ["vendor-chunks/m3u8stream"];
exports.modules = {

/***/ "(rsc)/./node_modules/m3u8stream/dist/dash-mpd-parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/m3u8stream/dist/dash-mpd-parser.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst sax_1 = __importDefault(__webpack_require__(/*! sax */ \"(rsc)/./node_modules/sax/lib/sax.js\"));\nconst parse_time_1 = __webpack_require__(/*! ./parse-time */ \"(rsc)/./node_modules/m3u8stream/dist/parse-time.js\");\n/**\n * A wrapper around sax that emits segments.\n */\nclass DashMPDParser extends stream_1.Writable {\n    constructor(targetID) {\n        super();\n        this._parser = sax_1.default.createStream(false, { lowercase: true });\n        this._parser.on('error', this.destroy.bind(this));\n        let lastTag;\n        let currtime = 0;\n        let seq = 0;\n        let segmentTemplate;\n        let timescale, offset, duration, baseURL;\n        let timeline = [];\n        let getSegments = false;\n        let gotSegments = false;\n        let isStatic;\n        let treeLevel;\n        let periodStart;\n        const tmpl = (str) => {\n            const context = {\n                RepresentationID: targetID,\n                Number: seq,\n                Time: currtime,\n            };\n            return str.replace(/\\$(\\w+)\\$/g, (m, p1) => `${context[p1]}`);\n        };\n        this._parser.on('opentag', node => {\n            switch (node.name) {\n                case 'mpd':\n                    currtime =\n                        node.attributes.availabilitystarttime ?\n                            new Date(node.attributes.availabilitystarttime).getTime() : 0;\n                    isStatic = node.attributes.type !== 'dynamic';\n                    break;\n                case 'period':\n                    // Reset everything on <Period> tag.\n                    seq = 0;\n                    timescale = 1000;\n                    duration = 0;\n                    offset = 0;\n                    baseURL = [];\n                    treeLevel = 0;\n                    periodStart = parse_time_1.durationStr(node.attributes.start) || 0;\n                    break;\n                case 'segmentlist':\n                    seq = parseInt(node.attributes.startnumber) || seq;\n                    timescale = parseInt(node.attributes.timescale) || timescale;\n                    duration = parseInt(node.attributes.duration) || duration;\n                    offset = parseInt(node.attributes.presentationtimeoffset) || offset;\n                    break;\n                case 'segmenttemplate':\n                    segmentTemplate = node.attributes;\n                    seq = parseInt(node.attributes.startnumber) || seq;\n                    timescale = parseInt(node.attributes.timescale) || timescale;\n                    break;\n                case 'segmenttimeline':\n                case 'baseurl':\n                    lastTag = node.name;\n                    break;\n                case 's':\n                    timeline.push({\n                        duration: parseInt(node.attributes.d),\n                        repeat: parseInt(node.attributes.r),\n                        time: parseInt(node.attributes.t),\n                    });\n                    break;\n                case 'adaptationset':\n                case 'representation':\n                    treeLevel++;\n                    if (!targetID) {\n                        targetID = node.attributes.id;\n                    }\n                    getSegments = node.attributes.id === `${targetID}`;\n                    if (getSegments) {\n                        if (periodStart) {\n                            currtime += periodStart;\n                        }\n                        if (offset) {\n                            currtime -= offset / timescale * 1000;\n                        }\n                        this.emit('starttime', currtime);\n                    }\n                    break;\n                case 'initialization':\n                    if (getSegments) {\n                        this.emit('item', {\n                            url: baseURL.filter(s => !!s).join('') + node.attributes.sourceurl,\n                            seq: seq,\n                            init: true,\n                            duration: 0,\n                        });\n                    }\n                    break;\n                case 'segmenturl':\n                    if (getSegments) {\n                        gotSegments = true;\n                        let tl = timeline.shift();\n                        let segmentDuration = ((tl === null || tl === void 0 ? void 0 : tl.duration) || duration) / timescale * 1000;\n                        this.emit('item', {\n                            url: baseURL.filter(s => !!s).join('') + node.attributes.media,\n                            seq: seq++,\n                            duration: segmentDuration,\n                        });\n                        currtime += segmentDuration;\n                    }\n                    break;\n            }\n        });\n        const onEnd = () => {\n            if (isStatic) {\n                this.emit('endlist');\n            }\n            if (!getSegments) {\n                this.destroy(Error(`Representation '${targetID}' not found`));\n            }\n            else {\n                this.emit('end');\n            }\n        };\n        this._parser.on('closetag', tagName => {\n            switch (tagName) {\n                case 'adaptationset':\n                case 'representation':\n                    treeLevel--;\n                    if (segmentTemplate && timeline.length) {\n                        gotSegments = true;\n                        if (segmentTemplate.initialization) {\n                            this.emit('item', {\n                                url: baseURL.filter(s => !!s).join('') +\n                                    tmpl(segmentTemplate.initialization),\n                                seq: seq,\n                                init: true,\n                                duration: 0,\n                            });\n                        }\n                        for (let { duration: itemDuration, repeat, time } of timeline) {\n                            itemDuration = itemDuration / timescale * 1000;\n                            repeat = repeat || 1;\n                            currtime = time || currtime;\n                            for (let i = 0; i < repeat; i++) {\n                                this.emit('item', {\n                                    url: baseURL.filter(s => !!s).join('') +\n                                        tmpl(segmentTemplate.media),\n                                    seq: seq++,\n                                    duration: itemDuration,\n                                });\n                                currtime += itemDuration;\n                            }\n                        }\n                    }\n                    if (gotSegments) {\n                        this.emit('endearly');\n                        onEnd();\n                        this._parser.removeAllListeners();\n                        this.removeAllListeners('finish');\n                    }\n                    break;\n            }\n        });\n        this._parser.on('text', text => {\n            if (lastTag === 'baseurl') {\n                baseURL[treeLevel] = text;\n                lastTag = null;\n            }\n        });\n        this.on('finish', onEnd);\n    }\n    _write(chunk, encoding, callback) {\n        this._parser.write(chunk);\n        callback();\n    }\n}\nexports[\"default\"] = DashMPDParser;\n//# sourceMappingURL=dash-mpd-parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbTN1OHN0cmVhbS9kaXN0L2Rhc2gtbXBkLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLDhCQUE4QixtQkFBTyxDQUFDLGdEQUFLO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLHdFQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxpQkFBaUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFlBQVk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLG1DQUFtQyx1Q0FBdUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQnVyYWtcXERvY3VtZW50c1xcR2l0SHViXFx5b3V0dWJlLWRvd25sb2FkZXJcXG5vZGVfbW9kdWxlc1xcbTN1OHN0cmVhbVxcZGlzdFxcZGFzaC1tcGQtcGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3Qgc2F4XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInNheFwiKSk7XG5jb25zdCBwYXJzZV90aW1lXzEgPSByZXF1aXJlKFwiLi9wYXJzZS10aW1lXCIpO1xuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHNheCB0aGF0IGVtaXRzIHNlZ21lbnRzLlxuICovXG5jbGFzcyBEYXNoTVBEUGFyc2VyIGV4dGVuZHMgc3RyZWFtXzEuV3JpdGFibGUge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldElEKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3BhcnNlciA9IHNheF8xLmRlZmF1bHQuY3JlYXRlU3RyZWFtKGZhbHNlLCB7IGxvd2VyY2FzZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5fcGFyc2VyLm9uKCdlcnJvcicsIHRoaXMuZGVzdHJveS5iaW5kKHRoaXMpKTtcbiAgICAgICAgbGV0IGxhc3RUYWc7XG4gICAgICAgIGxldCBjdXJydGltZSA9IDA7XG4gICAgICAgIGxldCBzZXEgPSAwO1xuICAgICAgICBsZXQgc2VnbWVudFRlbXBsYXRlO1xuICAgICAgICBsZXQgdGltZXNjYWxlLCBvZmZzZXQsIGR1cmF0aW9uLCBiYXNlVVJMO1xuICAgICAgICBsZXQgdGltZWxpbmUgPSBbXTtcbiAgICAgICAgbGV0IGdldFNlZ21lbnRzID0gZmFsc2U7XG4gICAgICAgIGxldCBnb3RTZWdtZW50cyA9IGZhbHNlO1xuICAgICAgICBsZXQgaXNTdGF0aWM7XG4gICAgICAgIGxldCB0cmVlTGV2ZWw7XG4gICAgICAgIGxldCBwZXJpb2RTdGFydDtcbiAgICAgICAgY29uc3QgdG1wbCA9IChzdHIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgUmVwcmVzZW50YXRpb25JRDogdGFyZ2V0SUQsXG4gICAgICAgICAgICAgICAgTnVtYmVyOiBzZXEsXG4gICAgICAgICAgICAgICAgVGltZTogY3VycnRpbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXCQoXFx3KylcXCQvZywgKG0sIHAxKSA9PiBgJHtjb250ZXh0W3AxXX1gKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcGFyc2VyLm9uKCdvcGVudGFnJywgbm9kZSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUubmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21wZCc6XG4gICAgICAgICAgICAgICAgICAgIGN1cnJ0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cmlidXRlcy5hdmFpbGFiaWxpdHlzdGFydHRpbWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKG5vZGUuYXR0cmlidXRlcy5hdmFpbGFiaWxpdHlzdGFydHRpbWUpLmdldFRpbWUoKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGlzU3RhdGljID0gbm9kZS5hdHRyaWJ1dGVzLnR5cGUgIT09ICdkeW5hbWljJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncGVyaW9kJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgZXZlcnl0aGluZyBvbiA8UGVyaW9kPiB0YWcuXG4gICAgICAgICAgICAgICAgICAgIHNlcSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzY2FsZSA9IDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVSTCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0cmVlTGV2ZWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICBwZXJpb2RTdGFydCA9IHBhcnNlX3RpbWVfMS5kdXJhdGlvblN0cihub2RlLmF0dHJpYnV0ZXMuc3RhcnQpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlZ21lbnRsaXN0JzpcbiAgICAgICAgICAgICAgICAgICAgc2VxID0gcGFyc2VJbnQobm9kZS5hdHRyaWJ1dGVzLnN0YXJ0bnVtYmVyKSB8fCBzZXE7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzY2FsZSA9IHBhcnNlSW50KG5vZGUuYXR0cmlidXRlcy50aW1lc2NhbGUpIHx8IHRpbWVzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBwYXJzZUludChub2RlLmF0dHJpYnV0ZXMuZHVyYXRpb24pIHx8IGR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBwYXJzZUludChub2RlLmF0dHJpYnV0ZXMucHJlc2VudGF0aW9udGltZW9mZnNldCkgfHwgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzZWdtZW50dGVtcGxhdGUnOlxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50VGVtcGxhdGUgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgIHNlcSA9IHBhcnNlSW50KG5vZGUuYXR0cmlidXRlcy5zdGFydG51bWJlcikgfHwgc2VxO1xuICAgICAgICAgICAgICAgICAgICB0aW1lc2NhbGUgPSBwYXJzZUludChub2RlLmF0dHJpYnV0ZXMudGltZXNjYWxlKSB8fCB0aW1lc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlZ21lbnR0aW1lbGluZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnYmFzZXVybCc6XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUYWcgPSBub2RlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBwYXJzZUludChub2RlLmF0dHJpYnV0ZXMuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQ6IHBhcnNlSW50KG5vZGUuYXR0cmlidXRlcy5yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IHBhcnNlSW50KG5vZGUuYXR0cmlidXRlcy50KSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FkYXB0YXRpb25zZXQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlcHJlc2VudGF0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgdHJlZUxldmVsKys7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0SUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldElEID0gbm9kZS5hdHRyaWJ1dGVzLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdldFNlZ21lbnRzID0gbm9kZS5hdHRyaWJ1dGVzLmlkID09PSBgJHt0YXJnZXRJRH1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0U2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZXJpb2RTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJ0aW1lICs9IHBlcmlvZFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJ0aW1lIC09IG9mZnNldCAvIHRpbWVzY2FsZSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0YXJ0dGltZScsIGN1cnJ0aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpbml0aWFsaXphdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRTZWdtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdpdGVtJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYmFzZVVSTC5maWx0ZXIocyA9PiAhIXMpLmpvaW4oJycpICsgbm9kZS5hdHRyaWJ1dGVzLnNvdXJjZXVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXE6IHNlcSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2VnbWVudHVybCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRTZWdtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ290U2VnbWVudHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRsID0gdGltZWxpbmUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzZWdtZW50RHVyYXRpb24gPSAoKHRsID09PSBudWxsIHx8IHRsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0bC5kdXJhdGlvbikgfHwgZHVyYXRpb24pIC8gdGltZXNjYWxlICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaXRlbScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGJhc2VVUkwuZmlsdGVyKHMgPT4gISFzKS5qb2luKCcnKSArIG5vZGUuYXR0cmlidXRlcy5tZWRpYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXE6IHNlcSsrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBzZWdtZW50RHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJ0aW1lICs9IHNlZ21lbnREdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG9uRW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzU3RhdGljKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlbmRsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdldFNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KEVycm9yKGBSZXByZXNlbnRhdGlvbiAnJHt0YXJnZXRJRH0nIG5vdCBmb3VuZGApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BhcnNlci5vbignY2xvc2V0YWcnLCB0YWdOYW1lID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FkYXB0YXRpb25zZXQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlcHJlc2VudGF0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgdHJlZUxldmVsLS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50VGVtcGxhdGUgJiYgdGltZWxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RTZWdtZW50cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudFRlbXBsYXRlLmluaXRpYWxpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdpdGVtJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGJhc2VVUkwuZmlsdGVyKHMgPT4gISFzKS5qb2luKCcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBsKHNlZ21lbnRUZW1wbGF0ZS5pbml0aWFsaXphdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcTogc2VxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHsgZHVyYXRpb246IGl0ZW1EdXJhdGlvbiwgcmVwZWF0LCB0aW1lIH0gb2YgdGltZWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtRHVyYXRpb24gPSBpdGVtRHVyYXRpb24gLyB0aW1lc2NhbGUgKiAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHJlcGVhdCB8fCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJ0aW1lID0gdGltZSB8fCBjdXJydGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcGVhdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaXRlbScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYmFzZVVSTC5maWx0ZXIocyA9PiAhIXMpLmpvaW4oJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBsKHNlZ21lbnRUZW1wbGF0ZS5tZWRpYSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXE6IHNlcSsrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGl0ZW1EdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJ0aW1lICs9IGl0ZW1EdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdvdFNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2VuZGVhcmx5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2ZpbmlzaCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcGFyc2VyLm9uKCd0ZXh0JywgdGV4dCA9PiB7XG4gICAgICAgICAgICBpZiAobGFzdFRhZyA9PT0gJ2Jhc2V1cmwnKSB7XG4gICAgICAgICAgICAgICAgYmFzZVVSTFt0cmVlTGV2ZWxdID0gdGV4dDtcbiAgICAgICAgICAgICAgICBsYXN0VGFnID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2ZpbmlzaCcsIG9uRW5kKTtcbiAgICB9XG4gICAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fcGFyc2VyLndyaXRlKGNodW5rKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBEYXNoTVBEUGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGFzaC1tcGQtcGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/m3u8stream/dist/dash-mpd-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/m3u8stream/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/m3u8stream/dist/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst miniget_1 = __importDefault(__webpack_require__(/*! miniget */ \"(rsc)/./node_modules/miniget/dist/index.js\"));\nconst m3u8_parser_1 = __importDefault(__webpack_require__(/*! ./m3u8-parser */ \"(rsc)/./node_modules/m3u8stream/dist/m3u8-parser.js\"));\nconst dash_mpd_parser_1 = __importDefault(__webpack_require__(/*! ./dash-mpd-parser */ \"(rsc)/./node_modules/m3u8stream/dist/dash-mpd-parser.js\"));\nconst queue_1 = __webpack_require__(/*! ./queue */ \"(rsc)/./node_modules/m3u8stream/dist/queue.js\");\nconst parse_time_1 = __webpack_require__(/*! ./parse-time */ \"(rsc)/./node_modules/m3u8stream/dist/parse-time.js\");\nconst supportedParsers = {\n    m3u8: m3u8_parser_1.default,\n    'dash-mpd': dash_mpd_parser_1.default,\n};\nlet m3u8stream = ((playlistURL, options = {}) => {\n    const stream = new stream_1.PassThrough({ highWaterMark: options.highWaterMark });\n    const chunkReadahead = options.chunkReadahead || 3;\n    // 20 seconds.\n    const liveBuffer = options.liveBuffer || 20000;\n    const requestOptions = options.requestOptions;\n    const Parser = supportedParsers[options.parser || (/\\.mpd$/.test(playlistURL) ? 'dash-mpd' : 'm3u8')];\n    if (!Parser) {\n        throw TypeError(`parser '${options.parser}' not supported`);\n    }\n    let begin = 0;\n    if (typeof options.begin !== 'undefined') {\n        begin = typeof options.begin === 'string' ?\n            parse_time_1.humanStr(options.begin) :\n            Math.max(options.begin - liveBuffer, 0);\n    }\n    const forwardEvents = (req) => {\n        for (let event of ['abort', 'request', 'response', 'redirect', 'retry', 'reconnect']) {\n            req.on(event, stream.emit.bind(stream, event));\n        }\n    };\n    let currSegment;\n    const streamQueue = new queue_1.Queue((req, callback) => {\n        currSegment = req;\n        // Count the size manually, since the `content-length` header is not\n        // always there.\n        let size = 0;\n        req.on('data', (chunk) => size += chunk.length);\n        req.pipe(stream, { end: false });\n        req.on('end', () => callback(null, size));\n    }, { concurrency: 1 });\n    let segmentNumber = 0;\n    let downloaded = 0;\n    const requestQueue = new queue_1.Queue((segment, callback) => {\n        let reqOptions = Object.assign({}, requestOptions);\n        if (segment.range) {\n            reqOptions.headers = Object.assign({}, reqOptions.headers, {\n                Range: `bytes=${segment.range.start}-${segment.range.end}`,\n            });\n        }\n        let req = miniget_1.default(new URL(segment.url, playlistURL).toString(), reqOptions);\n        req.on('error', callback);\n        forwardEvents(req);\n        streamQueue.push(req, (_, size) => {\n            downloaded += +size;\n            stream.emit('progress', {\n                num: ++segmentNumber,\n                size: size,\n                duration: segment.duration,\n                url: segment.url,\n            }, requestQueue.total, downloaded);\n            callback(null);\n        });\n    }, { concurrency: chunkReadahead });\n    const onError = (err) => {\n        stream.emit('error', err);\n        // Stop on any error.\n        stream.end();\n    };\n    // When to look for items again.\n    let refreshThreshold;\n    let minRefreshTime;\n    let refreshTimeout;\n    let fetchingPlaylist = true;\n    let ended = false;\n    let isStatic = false;\n    let lastRefresh;\n    const onQueuedEnd = (err) => {\n        currSegment = null;\n        if (err) {\n            onError(err);\n        }\n        else if (!fetchingPlaylist && !ended && !isStatic &&\n            requestQueue.tasks.length + requestQueue.active <= refreshThreshold) {\n            let ms = Math.max(0, minRefreshTime - (Date.now() - lastRefresh));\n            fetchingPlaylist = true;\n            refreshTimeout = setTimeout(refreshPlaylist, ms);\n        }\n        else if ((ended || isStatic) &&\n            !requestQueue.tasks.length && !requestQueue.active) {\n            stream.end();\n        }\n    };\n    let currPlaylist;\n    let lastSeq;\n    let starttime = 0;\n    const refreshPlaylist = () => {\n        lastRefresh = Date.now();\n        currPlaylist = miniget_1.default(playlistURL, requestOptions);\n        currPlaylist.on('error', onError);\n        forwardEvents(currPlaylist);\n        const parser = currPlaylist.pipe(new Parser(options.id));\n        parser.on('starttime', (a) => {\n            if (starttime) {\n                return;\n            }\n            starttime = a;\n            if (typeof options.begin === 'string' && begin >= 0) {\n                begin += starttime;\n            }\n        });\n        parser.on('endlist', () => { isStatic = true; });\n        parser.on('endearly', currPlaylist.unpipe.bind(currPlaylist, parser));\n        let addedItems = [];\n        const addItem = (item) => {\n            if (!item.init) {\n                if (item.seq <= lastSeq) {\n                    return;\n                }\n                lastSeq = item.seq;\n            }\n            begin = item.time;\n            requestQueue.push(item, onQueuedEnd);\n            addedItems.push(item);\n        };\n        let tailedItems = [], tailedItemsDuration = 0;\n        parser.on('item', (item) => {\n            let timedItem = Object.assign({ time: starttime }, item);\n            if (begin <= timedItem.time) {\n                addItem(timedItem);\n            }\n            else {\n                tailedItems.push(timedItem);\n                tailedItemsDuration += timedItem.duration;\n                // Only keep the last `liveBuffer` of items.\n                while (tailedItems.length > 1 &&\n                    tailedItemsDuration - tailedItems[0].duration > liveBuffer) {\n                    const lastItem = tailedItems.shift();\n                    tailedItemsDuration -= lastItem.duration;\n                }\n            }\n            starttime += timedItem.duration;\n        });\n        parser.on('end', () => {\n            currPlaylist = null;\n            // If we are too ahead of the stream, make sure to get the\n            // latest available items with a small buffer.\n            if (!addedItems.length && tailedItems.length) {\n                tailedItems.forEach(item => { addItem(item); });\n            }\n            // Refresh the playlist when remaining segments get low.\n            refreshThreshold = Math.max(1, Math.ceil(addedItems.length * 0.01));\n            // Throttle refreshing the playlist by looking at the duration\n            // of live items added on this refresh.\n            minRefreshTime =\n                addedItems.reduce((total, item) => item.duration + total, 0);\n            fetchingPlaylist = false;\n            onQueuedEnd(null);\n        });\n    };\n    refreshPlaylist();\n    stream.end = () => {\n        ended = true;\n        streamQueue.die();\n        requestQueue.die();\n        clearTimeout(refreshTimeout);\n        currPlaylist === null || currPlaylist === void 0 ? void 0 : currPlaylist.destroy();\n        currSegment === null || currSegment === void 0 ? void 0 : currSegment.destroy();\n        stream_1.PassThrough.prototype.end.call(stream, null);\n        return stream;\n    };\n    return stream;\n});\nm3u8stream.parseTimestamp = parse_time_1.humanStr;\nmodule.exports = m3u8stream;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbTN1OHN0cmVhbS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxrQ0FBa0MsbUJBQU8sQ0FBQywyREFBUztBQUNuRCxzQ0FBc0MsbUJBQU8sQ0FBQywwRUFBZTtBQUM3RCwwQ0FBMEMsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDckUsZ0JBQWdCLG1CQUFPLENBQUMsOERBQVM7QUFDakMscUJBQXFCLG1CQUFPLENBQUMsd0VBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsOENBQThDLHNDQUFzQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0EsS0FBSyxJQUFJLGdCQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxpREFBaUQ7QUFDakQsZ0NBQWdDLG9CQUFvQixHQUFHLGtCQUFrQjtBQUN6RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxLQUFLLElBQUksNkJBQTZCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQnVyYWtcXERvY3VtZW50c1xcR2l0SHViXFx5b3V0dWJlLWRvd25sb2FkZXJcXG5vZGVfbW9kdWxlc1xcbTN1OHN0cmVhbVxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBtaW5pZ2V0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm1pbmlnZXRcIikpO1xuY29uc3QgbTN1OF9wYXJzZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tM3U4LXBhcnNlclwiKSk7XG5jb25zdCBkYXNoX21wZF9wYXJzZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9kYXNoLW1wZC1wYXJzZXJcIikpO1xuY29uc3QgcXVldWVfMSA9IHJlcXVpcmUoXCIuL3F1ZXVlXCIpO1xuY29uc3QgcGFyc2VfdGltZV8xID0gcmVxdWlyZShcIi4vcGFyc2UtdGltZVwiKTtcbmNvbnN0IHN1cHBvcnRlZFBhcnNlcnMgPSB7XG4gICAgbTN1ODogbTN1OF9wYXJzZXJfMS5kZWZhdWx0LFxuICAgICdkYXNoLW1wZCc6IGRhc2hfbXBkX3BhcnNlcl8xLmRlZmF1bHQsXG59O1xubGV0IG0zdThzdHJlYW0gPSAoKHBsYXlsaXN0VVJMLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgc3RyZWFtXzEuUGFzc1Rocm91Z2goeyBoaWdoV2F0ZXJNYXJrOiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgfSk7XG4gICAgY29uc3QgY2h1bmtSZWFkYWhlYWQgPSBvcHRpb25zLmNodW5rUmVhZGFoZWFkIHx8IDM7XG4gICAgLy8gMjAgc2Vjb25kcy5cbiAgICBjb25zdCBsaXZlQnVmZmVyID0gb3B0aW9ucy5saXZlQnVmZmVyIHx8IDIwMDAwO1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucztcbiAgICBjb25zdCBQYXJzZXIgPSBzdXBwb3J0ZWRQYXJzZXJzW29wdGlvbnMucGFyc2VyIHx8ICgvXFwubXBkJC8udGVzdChwbGF5bGlzdFVSTCkgPyAnZGFzaC1tcGQnIDogJ20zdTgnKV07XG4gICAgaWYgKCFQYXJzZXIpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKGBwYXJzZXIgJyR7b3B0aW9ucy5wYXJzZXJ9JyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICAgIGxldCBiZWdpbiA9IDA7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmJlZ2luICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBiZWdpbiA9IHR5cGVvZiBvcHRpb25zLmJlZ2luID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICBwYXJzZV90aW1lXzEuaHVtYW5TdHIob3B0aW9ucy5iZWdpbikgOlxuICAgICAgICAgICAgTWF0aC5tYXgob3B0aW9ucy5iZWdpbiAtIGxpdmVCdWZmZXIsIDApO1xuICAgIH1cbiAgICBjb25zdCBmb3J3YXJkRXZlbnRzID0gKHJlcSkgPT4ge1xuICAgICAgICBmb3IgKGxldCBldmVudCBvZiBbJ2Fib3J0JywgJ3JlcXVlc3QnLCAncmVzcG9uc2UnLCAncmVkaXJlY3QnLCAncmV0cnknLCAncmVjb25uZWN0J10pIHtcbiAgICAgICAgICAgIHJlcS5vbihldmVudCwgc3RyZWFtLmVtaXQuYmluZChzdHJlYW0sIGV2ZW50KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBjdXJyU2VnbWVudDtcbiAgICBjb25zdCBzdHJlYW1RdWV1ZSA9IG5ldyBxdWV1ZV8xLlF1ZXVlKChyZXEsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGN1cnJTZWdtZW50ID0gcmVxO1xuICAgICAgICAvLyBDb3VudCB0aGUgc2l6ZSBtYW51YWxseSwgc2luY2UgdGhlIGBjb250ZW50LWxlbmd0aGAgaGVhZGVyIGlzIG5vdFxuICAgICAgICAvLyBhbHdheXMgdGhlcmUuXG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgcmVxLm9uKCdkYXRhJywgKGNodW5rKSA9PiBzaXplICs9IGNodW5rLmxlbmd0aCk7XG4gICAgICAgIHJlcS5waXBlKHN0cmVhbSwgeyBlbmQ6IGZhbHNlIH0pO1xuICAgICAgICByZXEub24oJ2VuZCcsICgpID0+IGNhbGxiYWNrKG51bGwsIHNpemUpKTtcbiAgICB9LCB7IGNvbmN1cnJlbmN5OiAxIH0pO1xuICAgIGxldCBzZWdtZW50TnVtYmVyID0gMDtcbiAgICBsZXQgZG93bmxvYWRlZCA9IDA7XG4gICAgY29uc3QgcmVxdWVzdFF1ZXVlID0gbmV3IHF1ZXVlXzEuUXVldWUoKHNlZ21lbnQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGxldCByZXFPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICBpZiAoc2VnbWVudC5yYW5nZSkge1xuICAgICAgICAgICAgcmVxT3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxT3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgUmFuZ2U6IGBieXRlcz0ke3NlZ21lbnQucmFuZ2Uuc3RhcnR9LSR7c2VnbWVudC5yYW5nZS5lbmR9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXEgPSBtaW5pZ2V0XzEuZGVmYXVsdChuZXcgVVJMKHNlZ21lbnQudXJsLCBwbGF5bGlzdFVSTCkudG9TdHJpbmcoKSwgcmVxT3B0aW9ucyk7XG4gICAgICAgIHJlcS5vbignZXJyb3InLCBjYWxsYmFjayk7XG4gICAgICAgIGZvcndhcmRFdmVudHMocmVxKTtcbiAgICAgICAgc3RyZWFtUXVldWUucHVzaChyZXEsIChfLCBzaXplKSA9PiB7XG4gICAgICAgICAgICBkb3dubG9hZGVkICs9ICtzaXplO1xuICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ3Byb2dyZXNzJywge1xuICAgICAgICAgICAgICAgIG51bTogKytzZWdtZW50TnVtYmVyLFxuICAgICAgICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHNlZ21lbnQuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdXJsOiBzZWdtZW50LnVybCxcbiAgICAgICAgICAgIH0sIHJlcXVlc3RRdWV1ZS50b3RhbCwgZG93bmxvYWRlZCk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfSk7XG4gICAgfSwgeyBjb25jdXJyZW5jeTogY2h1bmtSZWFkYWhlYWQgfSk7XG4gICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgLy8gU3RvcCBvbiBhbnkgZXJyb3IuXG4gICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICB9O1xuICAgIC8vIFdoZW4gdG8gbG9vayBmb3IgaXRlbXMgYWdhaW4uXG4gICAgbGV0IHJlZnJlc2hUaHJlc2hvbGQ7XG4gICAgbGV0IG1pblJlZnJlc2hUaW1lO1xuICAgIGxldCByZWZyZXNoVGltZW91dDtcbiAgICBsZXQgZmV0Y2hpbmdQbGF5bGlzdCA9IHRydWU7XG4gICAgbGV0IGVuZGVkID0gZmFsc2U7XG4gICAgbGV0IGlzU3RhdGljID0gZmFsc2U7XG4gICAgbGV0IGxhc3RSZWZyZXNoO1xuICAgIGNvbnN0IG9uUXVldWVkRW5kID0gKGVycikgPT4ge1xuICAgICAgICBjdXJyU2VnbWVudCA9IG51bGw7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZmV0Y2hpbmdQbGF5bGlzdCAmJiAhZW5kZWQgJiYgIWlzU3RhdGljICYmXG4gICAgICAgICAgICByZXF1ZXN0UXVldWUudGFza3MubGVuZ3RoICsgcmVxdWVzdFF1ZXVlLmFjdGl2ZSA8PSByZWZyZXNoVGhyZXNob2xkKSB7XG4gICAgICAgICAgICBsZXQgbXMgPSBNYXRoLm1heCgwLCBtaW5SZWZyZXNoVGltZSAtIChEYXRlLm5vdygpIC0gbGFzdFJlZnJlc2gpKTtcbiAgICAgICAgICAgIGZldGNoaW5nUGxheWxpc3QgPSB0cnVlO1xuICAgICAgICAgICAgcmVmcmVzaFRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlZnJlc2hQbGF5bGlzdCwgbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChlbmRlZCB8fCBpc1N0YXRpYykgJiZcbiAgICAgICAgICAgICFyZXF1ZXN0UXVldWUudGFza3MubGVuZ3RoICYmICFyZXF1ZXN0UXVldWUuYWN0aXZlKSB7XG4gICAgICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBjdXJyUGxheWxpc3Q7XG4gICAgbGV0IGxhc3RTZXE7XG4gICAgbGV0IHN0YXJ0dGltZSA9IDA7XG4gICAgY29uc3QgcmVmcmVzaFBsYXlsaXN0ID0gKCkgPT4ge1xuICAgICAgICBsYXN0UmVmcmVzaCA9IERhdGUubm93KCk7XG4gICAgICAgIGN1cnJQbGF5bGlzdCA9IG1pbmlnZXRfMS5kZWZhdWx0KHBsYXlsaXN0VVJMLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIGN1cnJQbGF5bGlzdC5vbignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgZm9yd2FyZEV2ZW50cyhjdXJyUGxheWxpc3QpO1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBjdXJyUGxheWxpc3QucGlwZShuZXcgUGFyc2VyKG9wdGlvbnMuaWQpKTtcbiAgICAgICAgcGFyc2VyLm9uKCdzdGFydHRpbWUnLCAoYSkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXJ0dGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0dGltZSA9IGE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYmVnaW4gPT09ICdzdHJpbmcnICYmIGJlZ2luID49IDApIHtcbiAgICAgICAgICAgICAgICBiZWdpbiArPSBzdGFydHRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJzZXIub24oJ2VuZGxpc3QnLCAoKSA9PiB7IGlzU3RhdGljID0gdHJ1ZTsgfSk7XG4gICAgICAgIHBhcnNlci5vbignZW5kZWFybHknLCBjdXJyUGxheWxpc3QudW5waXBlLmJpbmQoY3VyclBsYXlsaXN0LCBwYXJzZXIpKTtcbiAgICAgICAgbGV0IGFkZGVkSXRlbXMgPSBbXTtcbiAgICAgICAgY29uc3QgYWRkSXRlbSA9IChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uaW5pdCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnNlcSA8PSBsYXN0U2VxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFNlcSA9IGl0ZW0uc2VxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmVnaW4gPSBpdGVtLnRpbWU7XG4gICAgICAgICAgICByZXF1ZXN0UXVldWUucHVzaChpdGVtLCBvblF1ZXVlZEVuZCk7XG4gICAgICAgICAgICBhZGRlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCB0YWlsZWRJdGVtcyA9IFtdLCB0YWlsZWRJdGVtc0R1cmF0aW9uID0gMDtcbiAgICAgICAgcGFyc2VyLm9uKCdpdGVtJywgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGxldCB0aW1lZEl0ZW0gPSBPYmplY3QuYXNzaWduKHsgdGltZTogc3RhcnR0aW1lIH0sIGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDw9IHRpbWVkSXRlbS50aW1lKSB7XG4gICAgICAgICAgICAgICAgYWRkSXRlbSh0aW1lZEl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFpbGVkSXRlbXMucHVzaCh0aW1lZEl0ZW0pO1xuICAgICAgICAgICAgICAgIHRhaWxlZEl0ZW1zRHVyYXRpb24gKz0gdGltZWRJdGVtLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkga2VlcCB0aGUgbGFzdCBgbGl2ZUJ1ZmZlcmAgb2YgaXRlbXMuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRhaWxlZEl0ZW1zLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFpbGVkSXRlbXNEdXJhdGlvbiAtIHRhaWxlZEl0ZW1zWzBdLmR1cmF0aW9uID4gbGl2ZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0SXRlbSA9IHRhaWxlZEl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRhaWxlZEl0ZW1zRHVyYXRpb24gLT0gbGFzdEl0ZW0uZHVyYXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnR0aW1lICs9IHRpbWVkSXRlbS5kdXJhdGlvbjtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcnNlci5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgY3VyclBsYXlsaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSB0b28gYWhlYWQgb2YgdGhlIHN0cmVhbSwgbWFrZSBzdXJlIHRvIGdldCB0aGVcbiAgICAgICAgICAgIC8vIGxhdGVzdCBhdmFpbGFibGUgaXRlbXMgd2l0aCBhIHNtYWxsIGJ1ZmZlci5cbiAgICAgICAgICAgIGlmICghYWRkZWRJdGVtcy5sZW5ndGggJiYgdGFpbGVkSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGFpbGVkSXRlbXMuZm9yRWFjaChpdGVtID0+IHsgYWRkSXRlbShpdGVtKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZWZyZXNoIHRoZSBwbGF5bGlzdCB3aGVuIHJlbWFpbmluZyBzZWdtZW50cyBnZXQgbG93LlxuICAgICAgICAgICAgcmVmcmVzaFRocmVzaG9sZCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChhZGRlZEl0ZW1zLmxlbmd0aCAqIDAuMDEpKTtcbiAgICAgICAgICAgIC8vIFRocm90dGxlIHJlZnJlc2hpbmcgdGhlIHBsYXlsaXN0IGJ5IGxvb2tpbmcgYXQgdGhlIGR1cmF0aW9uXG4gICAgICAgICAgICAvLyBvZiBsaXZlIGl0ZW1zIGFkZGVkIG9uIHRoaXMgcmVmcmVzaC5cbiAgICAgICAgICAgIG1pblJlZnJlc2hUaW1lID1cbiAgICAgICAgICAgICAgICBhZGRlZEl0ZW1zLnJlZHVjZSgodG90YWwsIGl0ZW0pID0+IGl0ZW0uZHVyYXRpb24gKyB0b3RhbCwgMCk7XG4gICAgICAgICAgICBmZXRjaGluZ1BsYXlsaXN0ID0gZmFsc2U7XG4gICAgICAgICAgICBvblF1ZXVlZEVuZChudWxsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZWZyZXNoUGxheWxpc3QoKTtcbiAgICBzdHJlYW0uZW5kID0gKCkgPT4ge1xuICAgICAgICBlbmRlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbVF1ZXVlLmRpZSgpO1xuICAgICAgICByZXF1ZXN0UXVldWUuZGllKCk7XG4gICAgICAgIGNsZWFyVGltZW91dChyZWZyZXNoVGltZW91dCk7XG4gICAgICAgIGN1cnJQbGF5bGlzdCA9PT0gbnVsbCB8fCBjdXJyUGxheWxpc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJQbGF5bGlzdC5kZXN0cm95KCk7XG4gICAgICAgIGN1cnJTZWdtZW50ID09PSBudWxsIHx8IGN1cnJTZWdtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyU2VnbWVudC5kZXN0cm95KCk7XG4gICAgICAgIHN0cmVhbV8xLlBhc3NUaHJvdWdoLnByb3RvdHlwZS5lbmQuY2FsbChzdHJlYW0sIG51bGwpO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH07XG4gICAgcmV0dXJuIHN0cmVhbTtcbn0pO1xubTN1OHN0cmVhbS5wYXJzZVRpbWVzdGFtcCA9IHBhcnNlX3RpbWVfMS5odW1hblN0cjtcbm1vZHVsZS5leHBvcnRzID0gbTN1OHN0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/m3u8stream/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/m3u8stream/dist/m3u8-parser.js":
/*!*****************************************************!*\
  !*** ./node_modules/m3u8stream/dist/m3u8-parser.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * A very simple m3u8 playlist file parser that detects tags and segments.\n */\nclass m3u8Parser extends stream_1.Writable {\n    constructor() {\n        super();\n        this._lastLine = '';\n        this._seq = 0;\n        this._nextItemDuration = null;\n        this._nextItemRange = null;\n        this._lastItemRangeEnd = 0;\n        this.on('finish', () => {\n            this._parseLine(this._lastLine);\n            this.emit('end');\n        });\n    }\n    _parseAttrList(value) {\n        let attrs = {};\n        let regex = /([A-Z0-9-]+)=(?:\"([^\"]*?)\"|([^,]*?))/g;\n        let match;\n        while ((match = regex.exec(value)) !== null) {\n            attrs[match[1]] = match[2] || match[3];\n        }\n        return attrs;\n    }\n    _parseRange(value) {\n        if (!value)\n            return null;\n        let svalue = value.split('@');\n        let start = svalue[1] ? parseInt(svalue[1]) : this._lastItemRangeEnd + 1;\n        let end = start + parseInt(svalue[0]) - 1;\n        let range = { start, end };\n        this._lastItemRangeEnd = range.end;\n        return range;\n    }\n    _parseLine(line) {\n        let match = line.match(/^#(EXT[A-Z0-9-]+)(?::(.*))?/);\n        if (match) {\n            // This is a tag.\n            const tag = match[1];\n            const value = match[2] || '';\n            switch (tag) {\n                case 'EXT-X-PROGRAM-DATE-TIME':\n                    this.emit('starttime', new Date(value).getTime());\n                    break;\n                case 'EXT-X-MEDIA-SEQUENCE':\n                    this._seq = parseInt(value);\n                    break;\n                case 'EXT-X-MAP': {\n                    let attrs = this._parseAttrList(value);\n                    if (!attrs.URI) {\n                        this.destroy(new Error('`EXT-X-MAP` found without required attribute `URI`'));\n                        return;\n                    }\n                    this.emit('item', {\n                        url: attrs.URI,\n                        seq: this._seq,\n                        init: true,\n                        duration: 0,\n                        range: this._parseRange(attrs.BYTERANGE),\n                    });\n                    break;\n                }\n                case 'EXT-X-BYTERANGE': {\n                    this._nextItemRange = this._parseRange(value);\n                    break;\n                }\n                case 'EXTINF':\n                    this._nextItemDuration =\n                        Math.round(parseFloat(value.split(',')[0]) * 1000);\n                    break;\n                case 'EXT-X-ENDLIST':\n                    this.emit('endlist');\n                    break;\n            }\n        }\n        else if (!/^#/.test(line) && line.trim()) {\n            // This is a segment\n            this.emit('item', {\n                url: line.trim(),\n                seq: this._seq++,\n                duration: this._nextItemDuration,\n                range: this._nextItemRange,\n            });\n            this._nextItemRange = null;\n        }\n    }\n    _write(chunk, encoding, callback) {\n        let lines = chunk.toString('utf8').split('\\n');\n        if (this._lastLine) {\n            lines[0] = this._lastLine + lines[0];\n        }\n        lines.forEach((line, i) => {\n            if (this.destroyed)\n                return;\n            if (i < lines.length - 1) {\n                this._parseLine(line);\n            }\n            else {\n                // Save the last line in case it has been broken up.\n                this._lastLine = line;\n            }\n        });\n        callback();\n    }\n}\nexports[\"default\"] = m3u8Parser;\n//# sourceMappingURL=m3u8-parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbTN1OHN0cmVhbS9kaXN0L20zdTgtcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQnVyYWtcXERvY3VtZW50c1xcR2l0SHViXFx5b3V0dWJlLWRvd25sb2FkZXJcXG5vZGVfbW9kdWxlc1xcbTN1OHN0cmVhbVxcZGlzdFxcbTN1OC1wYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG4vKipcbiAqIEEgdmVyeSBzaW1wbGUgbTN1OCBwbGF5bGlzdCBmaWxlIHBhcnNlciB0aGF0IGRldGVjdHMgdGFncyBhbmQgc2VnbWVudHMuXG4gKi9cbmNsYXNzIG0zdThQYXJzZXIgZXh0ZW5kcyBzdHJlYW1fMS5Xcml0YWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2xhc3RMaW5lID0gJyc7XG4gICAgICAgIHRoaXMuX3NlcSA9IDA7XG4gICAgICAgIHRoaXMuX25leHRJdGVtRHVyYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9uZXh0SXRlbVJhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdEl0ZW1SYW5nZUVuZCA9IDA7XG4gICAgICAgIHRoaXMub24oJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlTGluZSh0aGlzLl9sYXN0TGluZSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3BhcnNlQXR0ckxpc3QodmFsdWUpIHtcbiAgICAgICAgbGV0IGF0dHJzID0ge307XG4gICAgICAgIGxldCByZWdleCA9IC8oW0EtWjAtOS1dKyk9KD86XCIoW15cIl0qPylcInwoW14sXSo/KSkvZztcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmVnZXguZXhlYyh2YWx1ZSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyc1ttYXRjaFsxXV0gPSBtYXRjaFsyXSB8fCBtYXRjaFszXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgfVxuICAgIF9wYXJzZVJhbmdlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHN2YWx1ZSA9IHZhbHVlLnNwbGl0KCdAJyk7XG4gICAgICAgIGxldCBzdGFydCA9IHN2YWx1ZVsxXSA/IHBhcnNlSW50KHN2YWx1ZVsxXSkgOiB0aGlzLl9sYXN0SXRlbVJhbmdlRW5kICsgMTtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgcGFyc2VJbnQoc3ZhbHVlWzBdKSAtIDE7XG4gICAgICAgIGxldCByYW5nZSA9IHsgc3RhcnQsIGVuZCB9O1xuICAgICAgICB0aGlzLl9sYXN0SXRlbVJhbmdlRW5kID0gcmFuZ2UuZW5kO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICAgIF9wYXJzZUxpbmUobGluZSkge1xuICAgICAgICBsZXQgbWF0Y2ggPSBsaW5lLm1hdGNoKC9eIyhFWFRbQS1aMC05LV0rKSg/OjooLiopKT8vKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgdGFnLlxuICAgICAgICAgICAgY29uc3QgdGFnID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1hdGNoWzJdIHx8ICcnO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdFWFQtWC1QUk9HUkFNLURBVEUtVElNRSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhcnR0aW1lJywgbmV3IERhdGUodmFsdWUpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0VYVC1YLU1FRElBLVNFUVVFTkNFJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VxID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdFWFQtWC1NQVAnOiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhdHRycyA9IHRoaXMuX3BhcnNlQXR0ckxpc3QodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWF0dHJzLlVSSSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KG5ldyBFcnJvcignYEVYVC1YLU1BUGAgZm91bmQgd2l0aG91dCByZXF1aXJlZCBhdHRyaWJ1dGUgYFVSSWAnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdpdGVtJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBhdHRycy5VUkksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXE6IHRoaXMuX3NlcSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB0aGlzLl9wYXJzZVJhbmdlKGF0dHJzLkJZVEVSQU5HRSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnRVhULVgtQllURVJBTkdFJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXh0SXRlbVJhbmdlID0gdGhpcy5fcGFyc2VSYW5nZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdFWFRJTkYnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXh0SXRlbUR1cmF0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQocGFyc2VGbG9hdCh2YWx1ZS5zcGxpdCgnLCcpWzBdKSAqIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdFWFQtWC1FTkRMSVNUJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlbmRsaXN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEvXiMvLnRlc3QobGluZSkgJiYgbGluZS50cmltKCkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzZWdtZW50XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2l0ZW0nLCB7XG4gICAgICAgICAgICAgICAgdXJsOiBsaW5lLnRyaW0oKSxcbiAgICAgICAgICAgICAgICBzZXE6IHRoaXMuX3NlcSsrLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLl9uZXh0SXRlbUR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHJhbmdlOiB0aGlzLl9uZXh0SXRlbVJhbmdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9uZXh0SXRlbVJhbmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgbGluZXMgPSBjaHVuay50b1N0cmluZygndXRmOCcpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RMaW5lKSB7XG4gICAgICAgICAgICBsaW5lc1swXSA9IHRoaXMuX2xhc3RMaW5lICsgbGluZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgbGluZXMuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChpIDwgbGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTGluZShsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgbGluZSBpbiBjYXNlIGl0IGhhcyBiZWVuIGJyb2tlbiB1cC5cbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0TGluZSA9IGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IG0zdThQYXJzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tM3U4LXBhcnNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/m3u8stream/dist/m3u8-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/m3u8stream/dist/parse-time.js":
/*!****************************************************!*\
  !*** ./node_modules/m3u8stream/dist/parse-time.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.durationStr = exports.humanStr = void 0;\nconst numberFormat = /^\\d+$/;\nconst timeFormat = /^(?:(?:(\\d+):)?(\\d{1,2}):)?(\\d{1,2})(?:\\.(\\d{3}))?$/;\nconst timeUnits = {\n    ms: 1,\n    s: 1000,\n    m: 60000,\n    h: 3600000,\n};\n/**\n * Converts human friendly time to milliseconds. Supports the format\n * 00:00:00.000 for hours, minutes, seconds, and milliseconds respectively.\n * And 0ms, 0s, 0m, 0h, and together 1m1s.\n *\n * @param {number|string} time\n * @returns {number}\n */\nexports.humanStr = (time) => {\n    if (typeof time === 'number') {\n        return time;\n    }\n    if (numberFormat.test(time)) {\n        return +time;\n    }\n    const firstFormat = timeFormat.exec(time);\n    if (firstFormat) {\n        return (+(firstFormat[1] || 0) * timeUnits.h) +\n            (+(firstFormat[2] || 0) * timeUnits.m) +\n            (+firstFormat[3] * timeUnits.s) +\n            +(firstFormat[4] || 0);\n    }\n    else {\n        let total = 0;\n        const r = /(-?\\d+)(ms|s|m|h)/g;\n        let rs;\n        while ((rs = r.exec(time)) !== null) {\n            total += +rs[1] * timeUnits[rs[2]];\n        }\n        return total;\n    }\n};\n/**\n * Parses a duration string in the form of \"123.456S\", returns milliseconds.\n *\n * @param {string} time\n * @returns {number}\n */\nexports.durationStr = (time) => {\n    let total = 0;\n    const r = /(\\d+(?:\\.\\d+)?)(S|M|H)/g;\n    let rs;\n    while ((rs = r.exec(time)) !== null) {\n        total += +rs[1] * timeUnits[rs[2].toLowerCase()];\n    }\n    return total;\n};\n//# sourceMappingURL=parse-time.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbTN1OHN0cmVhbS9kaXN0L3BhcnNlLXRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsZ0JBQWdCO0FBQ3RDO0FBQ0EsdUNBQXVDLElBQUksUUFBUSxJQUFJLFVBQVUsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQnVyYWtcXERvY3VtZW50c1xcR2l0SHViXFx5b3V0dWJlLWRvd25sb2FkZXJcXG5vZGVfbW9kdWxlc1xcbTN1OHN0cmVhbVxcZGlzdFxccGFyc2UtdGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZHVyYXRpb25TdHIgPSBleHBvcnRzLmh1bWFuU3RyID0gdm9pZCAwO1xuY29uc3QgbnVtYmVyRm9ybWF0ID0gL15cXGQrJC87XG5jb25zdCB0aW1lRm9ybWF0ID0gL14oPzooPzooXFxkKyk6KT8oXFxkezEsMn0pOik/KFxcZHsxLDJ9KSg/OlxcLihcXGR7M30pKT8kLztcbmNvbnN0IHRpbWVVbml0cyA9IHtcbiAgICBtczogMSxcbiAgICBzOiAxMDAwLFxuICAgIG06IDYwMDAwLFxuICAgIGg6IDM2MDAwMDAsXG59O1xuLyoqXG4gKiBDb252ZXJ0cyBodW1hbiBmcmllbmRseSB0aW1lIHRvIG1pbGxpc2Vjb25kcy4gU3VwcG9ydHMgdGhlIGZvcm1hdFxuICogMDA6MDA6MDAuMDAwIGZvciBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyByZXNwZWN0aXZlbHkuXG4gKiBBbmQgMG1zLCAwcywgMG0sIDBoLCBhbmQgdG9nZXRoZXIgMW0xcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHRpbWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMuaHVtYW5TdHIgPSAodGltZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdGltZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRpbWU7XG4gICAgfVxuICAgIGlmIChudW1iZXJGb3JtYXQudGVzdCh0aW1lKSkge1xuICAgICAgICByZXR1cm4gK3RpbWU7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0Rm9ybWF0ID0gdGltZUZvcm1hdC5leGVjKHRpbWUpO1xuICAgIGlmIChmaXJzdEZvcm1hdCkge1xuICAgICAgICByZXR1cm4gKCsoZmlyc3RGb3JtYXRbMV0gfHwgMCkgKiB0aW1lVW5pdHMuaCkgK1xuICAgICAgICAgICAgKCsoZmlyc3RGb3JtYXRbMl0gfHwgMCkgKiB0aW1lVW5pdHMubSkgK1xuICAgICAgICAgICAgKCtmaXJzdEZvcm1hdFszXSAqIHRpbWVVbml0cy5zKSArXG4gICAgICAgICAgICArKGZpcnN0Rm9ybWF0WzRdIHx8IDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgY29uc3QgciA9IC8oLT9cXGQrKShtc3xzfG18aCkvZztcbiAgICAgICAgbGV0IHJzO1xuICAgICAgICB3aGlsZSAoKHJzID0gci5leGVjKHRpbWUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdG90YWwgKz0gK3JzWzFdICogdGltZVVuaXRzW3JzWzJdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxufTtcbi8qKlxuICogUGFyc2VzIGEgZHVyYXRpb24gc3RyaW5nIGluIHRoZSBmb3JtIG9mIFwiMTIzLjQ1NlNcIiwgcmV0dXJucyBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRpbWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMuZHVyYXRpb25TdHIgPSAodGltZSkgPT4ge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgY29uc3QgciA9IC8oXFxkKyg/OlxcLlxcZCspPykoU3xNfEgpL2c7XG4gICAgbGV0IHJzO1xuICAgIHdoaWxlICgocnMgPSByLmV4ZWModGltZSkpICE9PSBudWxsKSB7XG4gICAgICAgIHRvdGFsICs9ICtyc1sxXSAqIHRpbWVVbml0c1tyc1syXS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLXRpbWUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/m3u8stream/dist/parse-time.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/m3u8stream/dist/queue.js":
/*!***********************************************!*\
  !*** ./node_modules/m3u8stream/dist/queue.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Queue = void 0;\nclass Queue {\n    /**\n     * A really simple queue with concurrency.\n     *\n     * @param {Function} worker\n     * @param {Object} options\n     * @param {!number} options.concurrency\n     */\n    constructor(worker, options = {}) {\n        this._worker = worker;\n        this._concurrency = options.concurrency || 1;\n        this.tasks = [];\n        this.total = 0;\n        this.active = 0;\n    }\n    /**\n     * Push a task to the queue.\n     *\n     *  @param {T} item\n     *  @param {!Function} callback\n     */\n    push(item, callback) {\n        this.tasks.push({ item, callback });\n        this.total++;\n        this._next();\n    }\n    /**\n     * Process next job in queue.\n     */\n    _next() {\n        if (this.active >= this._concurrency || !this.tasks.length) {\n            return;\n        }\n        const { item, callback } = this.tasks.shift();\n        let callbackCalled = false;\n        this.active++;\n        this._worker(item, (err, result) => {\n            if (callbackCalled) {\n                return;\n            }\n            this.active--;\n            callbackCalled = true;\n            callback === null || callback === void 0 ? void 0 : callback(err, result);\n            this._next();\n        });\n    }\n    /**\n     * Stops processing queued jobs.\n     */\n    die() {\n        this.tasks = [];\n    }\n}\nexports.Queue = Queue;\n//# sourceMappingURL=queue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbTN1OHN0cmVhbS9kaXN0L3F1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixHQUFHO0FBQ25CLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEJ1cmFrXFxEb2N1bWVudHNcXEdpdEh1YlxceW91dHViZS1kb3dubG9hZGVyXFxub2RlX21vZHVsZXNcXG0zdThzdHJlYW1cXGRpc3RcXHF1ZXVlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5RdWV1ZSA9IHZvaWQgMDtcbmNsYXNzIFF1ZXVlIHtcbiAgICAvKipcbiAgICAgKiBBIHJlYWxseSBzaW1wbGUgcXVldWUgd2l0aCBjb25jdXJyZW5jeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdvcmtlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSBvcHRpb25zLmNvbmN1cnJlbmN5XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iod29ya2VyLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5fd29ya2VyID0gd29ya2VyO1xuICAgICAgICB0aGlzLl9jb25jdXJyZW5jeSA9IG9wdGlvbnMuY29uY3VycmVuY3kgfHwgMTtcbiAgICAgICAgdGhpcy50YXNrcyA9IFtdO1xuICAgICAgICB0aGlzLnRvdGFsID0gMDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoIGEgdGFzayB0byB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIHtUfSBpdGVtXG4gICAgICogIEBwYXJhbSB7IUZ1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIHB1c2goaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy50YXNrcy5wdXNoKHsgaXRlbSwgY2FsbGJhY2sgfSk7XG4gICAgICAgIHRoaXMudG90YWwrKztcbiAgICAgICAgdGhpcy5fbmV4dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIG5leHQgam9iIGluIHF1ZXVlLlxuICAgICAqL1xuICAgIF9uZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPj0gdGhpcy5fY29uY3VycmVuY3kgfHwgIXRoaXMudGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpdGVtLCBjYWxsYmFjayB9ID0gdGhpcy50YXNrcy5zaGlmdCgpO1xuICAgICAgICBsZXQgY2FsbGJhY2tDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgdGhpcy5fd29ya2VyKGl0ZW0sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrQ2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgICAgIGNhbGxiYWNrQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBwcm9jZXNzaW5nIHF1ZXVlZCBqb2JzLlxuICAgICAqL1xuICAgIGRpZSgpIHtcbiAgICAgICAgdGhpcy50YXNrcyA9IFtdO1xuICAgIH1cbn1cbmV4cG9ydHMuUXVldWUgPSBRdWV1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXVlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/m3u8stream/dist/queue.js\n");

/***/ })

};
;